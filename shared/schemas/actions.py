"""
AutoHeal AI - Action Schemas
============================

Pydantic models for healing actions, plans, and audit entries.
These schemas define the contract for the execution and audit layers.
"""

from datetime import datetime
from typing import Optional, Any
from pydantic import BaseModel, Field
from enum import Enum

from shared.constants import HealingAction as HealingActionType, Severity


class ActionParameter(BaseModel):
    """A single parameter for a healing action."""
    
    name: str = Field(..., description="Parameter name")
    value: Any = Field(..., description="Parameter value")
    description: Optional[str] = Field(None, description="What this parameter controls")


class HealingAction(BaseModel):
    """
    Represents a single executable healing action.
    
    This is the atomic unit of work that the K8s Executor receives.
    """
    
    action_id: str = Field(
        ...,
        description="Unique action identifier"
    )
    action_type: HealingActionType = Field(
        ...,
        description="Type of healing action"
    )
    target_resource: str = Field(
        ...,
        description="Name of the Kubernetes resource (e.g., deployment name)"
    )
    target_namespace: str = Field(
        default="default",
        description="Kubernetes namespace"
    )
    target_kind: str = Field(
        default="Deployment",
        description="Kubernetes resource kind (Deployment, Pod, etc.)"
    )
    parameters: list[ActionParameter] = Field(
        default_factory=list,
        description="Action-specific parameters"
    )
    dry_run: bool = Field(
        default=False,
        description="If true, simulate but don't execute"
    )
    timeout_seconds: int = Field(
        default=300,
        description="Maximum time to wait for action completion"
    )
    
    class Config:
        use_enum_values = True


class HealingPlan(BaseModel):
    """
    A complete healing plan generated by the AutoHeal Agent.
    
    Contains the agent's reasoning, risk assessment, and ordered
    list of actions to execute.
    """
    
    plan_id: str = Field(
        ...,
        description="Unique plan identifier"
    )
    incident_id: str = Field(
        ...,
        description="Related incident ID"
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When the plan was created"
    )
    
    # Observation phase output
    observed_state: dict[str, Any] = Field(
        default_factory=dict,
        description="Current state of the affected system"
    )
    
    # Analysis phase output
    root_cause_analysis: str = Field(
        ...,
        description="Analysis of the incident root cause"
    )
    contributing_factors: list[str] = Field(
        default_factory=list,
        description="Factors contributing to the incident"
    )
    
    # Planning phase output
    strategy: str = Field(
        ...,
        description="High-level healing strategy (rollback, scale, restart)"
    )
    reasoning: str = Field(
        ...,
        description="Detailed reasoning for choosing this strategy"
    )
    expected_outcome: str = Field(
        ...,
        description="Expected result after healing"
    )
    estimated_duration_seconds: int = Field(
        default=120,
        description="Estimated time to complete healing"
    )
    
    # Risk assessment
    risk_level: str = Field(
        default="low",
        description="Risk level of the healing action (low, medium, high)"
    )
    risk_factors: list[str] = Field(
        default_factory=list,
        description="Identified risk factors"
    )
    mitigation_steps: list[str] = Field(
        default_factory=list,
        description="Steps to mitigate identified risks"
    )
    rollback_plan: Optional[str] = Field(
        None,
        description="How to rollback if healing fails"
    )
    
    # Actions to execute
    actions: list[HealingAction] = Field(
        default_factory=list,
        description="Ordered list of actions to execute"
    )
    
    # Verification criteria
    verification_checks: list[str] = Field(
        default_factory=list,
        description="Checks to perform after healing"
    )
    success_criteria: str = Field(
        ...,
        description="How to determine if healing was successful"
    )


class ActionResult(BaseModel):
    """
    Result of executing a single healing action.
    
    Returned by the K8s Executor after action completion.
    """
    
    action_id: str = Field(
        ...,
        description="ID of the executed action"
    )
    success: bool = Field(
        ...,
        description="Whether the action succeeded"
    )
    executed_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When the action was executed"
    )
    duration_seconds: float = Field(
        ...,
        description="How long the action took"
    )
    
    # Execution details
    command_executed: Optional[str] = Field(
        None,
        description="The actual command/API call made"
    )
    output: Optional[str] = Field(
        None,
        description="Output from the action"
    )
    error_message: Optional[str] = Field(
        None,
        description="Error message if action failed"
    )
    
    # Resource state after action
    resource_state: dict[str, Any] = Field(
        default_factory=dict,
        description="State of the resource after action"
    )
    
    # For dry-run mode
    dry_run: bool = Field(
        default=False,
        description="Whether this was a dry run"
    )
    would_have_executed: Optional[str] = Field(
        None,
        description="What would have been executed in non-dry-run mode"
    )


class AuditEntry(BaseModel):
    """
    Audit log entry for compliance and traceability.
    
    Every significant action in the system generates an audit entry.
    """
    
    audit_id: str = Field(
        ...,
        description="Unique audit entry ID"
    )
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="When the entry was created"
    )
    correlation_id: Optional[str] = Field(
        None,
        description="Correlation ID for tracing"
    )
    
    # What happened
    event_type: str = Field(
        ...,
        description="Type of audited event"
    )
    event_source: str = Field(
        ...,
        description="Service that generated the event"
    )
    event_summary: str = Field(
        ...,
        description="Human-readable summary"
    )
    
    # Context
    incident_id: Optional[str] = Field(
        None,
        description="Related incident ID"
    )
    healing_id: Optional[str] = Field(
        None,
        description="Related healing ID"
    )
    action_id: Optional[str] = Field(
        None,
        description="Related action ID"
    )
    
    # Decision information (for agent decisions)
    decision_reasoning: Optional[str] = Field(
        None,
        description="Why this decision was made"
    )
    decision_alternatives: list[str] = Field(
        default_factory=list,
        description="Alternative options considered"
    )
    
    # Outcome
    outcome: str = Field(
        default="pending",
        description="Outcome of the action (success, failure, pending)"
    )
    outcome_details: Optional[str] = Field(
        None,
        description="Details about the outcome"
    )
    
    # Full details for compliance
    full_context: dict[str, Any] = Field(
        default_factory=dict,
        description="Complete context for compliance review"
    )
    
    # Metadata
    actor: str = Field(
        default="autoheal-agent",
        description="Who/what performed the action"
    )
    target_resources: list[str] = Field(
        default_factory=list,
        description="Resources affected"
    )
    severity: Severity = Field(
        default=Severity.INFO,
        description="Severity level of the event"
    )
    
    class Config:
        use_enum_values = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
